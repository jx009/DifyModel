const { buildPlannedKbHits } = require('./examRouter')

const DEFAULT_TIMEOUT_MS = 15_000

function makeProviderError(code, message, details) {
  const error = new Error(message)
  error.code = code
  if (details) error.details = details
  return error
}

function isDifyEnabled() {
  const raw = String(process.env.DIFY_ENABLED || '')
  if (!raw) {
    return Boolean(process.env.DIFY_BASE_URL && process.env.DIFY_API_KEY)
  }
  return raw.toLowerCase() === 'true'
}

function parseWorkflowApiKeyMap() {
  const raw = process.env.DIFY_API_KEYS_BY_WORKFLOW_ID || '{}'
  try {
    const parsed = JSON.parse(raw)
    if (!parsed || typeof parsed !== 'object') return {}
    return parsed
  } catch (_error) {
    return {}
  }
}

function getDifyConfig() {
  return {
    enabled: isDifyEnabled(),
    baseUrl: (process.env.DIFY_BASE_URL || '').replace(/\/$/, ''),
    apiKey: process.env.DIFY_API_KEY || '',
    timeoutMs: Number(process.env.DIFY_TIMEOUT_MS || DEFAULT_TIMEOUT_MS),
    fallbackToMock: String(process.env.DIFY_FALLBACK_TO_MOCK || 'true').toLowerCase() !== 'false',
    userPrefix: process.env.DIFY_USER_PREFIX || 'difymodel',
    apiKeysByWorkflowId: parseWorkflowApiKeyMap()
  }
}

function resolveApiKey(cfg, workflowId) {
  if (workflowId && cfg.apiKeysByWorkflowId[workflowId]) {
    return cfg.apiKeysByWorkflowId[workflowId]
  }
  return cfg.apiKey
}

function buildDifyInput(payload, scenario, policy, traceId, tenantId, context) {
  return {
    inputs: {
      scenario_id: scenario.scenario_id,
      sub_type: context.subType || 'unknown',
      sub_type_profile: context.subTypeProfile || null,
      prompt_plan: context.promptPlan || null,
      workflow_hint: context.workflowId || null,
      kb_plan: context.knowledge || { enabled: false, kb_ids: [] },
      input: payload.input,
      context: payload.context || {},
      options: payload.options || {},
      policy,
      trace_id: traceId,
      retry_index: Number(context.retryIndex || 0)
    },
    response_mode: 'blocking',
    user: `${getDifyConfig().userPrefix}:${tenantId || 'anonymous'}:${traceId}`
  }
}

function parseUsage(data) {
  const usage = data.usage || {}
  return {
    token_in: Number(usage.prompt_tokens ?? usage.input_tokens ?? usage.total_tokens ?? 0),
    token_out: Number(usage.completion_tokens ?? usage.output_tokens ?? 0),
    total_tokens: Number(usage.total_tokens ?? 0),
    elapsed_time: Number(data.elapsed_time ?? usage.elapsed_time ?? 0),
    cost: Number(usage.total_price ?? usage.cost ?? 0)
  }
}

function normalizeDifyResult(traceId, scenarioId, responseJson, startedAt, context) {
  const elapsed = Date.now() - startedAt
  const data = responseJson && responseJson.data ? responseJson.data : {}
  const outputs = data.outputs || {}

  const answer = outputs.answer || outputs.result || outputs.output || data.answer || JSON.stringify(outputs)
  const confidenceRaw = outputs.confidence ?? data.confidence ?? 0.7
  const confidence = Number(Number(confidenceRaw).toFixed(2))

  const evidence = Array.isArray(outputs.evidence)
    ? outputs.evidence
    : outputs.reason
      ? [String(outputs.reason)]
      : ['response generated by dify workflow']

  const subType = outputs.sub_type || outputs.question_type || context.subType || 'unknown'
  const usageParsed = parseUsage(data)

  const hasUpstreamKbHits = Array.isArray(outputs.kb_hits) && outputs.kb_hits.length > 0
  const kbHits = hasUpstreamKbHits ? outputs.kb_hits : buildPlannedKbHits(context.knowledge)

  return {
    trace_id: traceId,
    scenario_id: scenarioId,
    sub_type: subType,
    status: 'completed',
    result: {
      answer: typeof answer === 'string' ? answer : JSON.stringify(answer),
      evidence,
      confidence: Number.isFinite(confidence) ? confidence : 0.7
    },
    metrics: {
      latency_ms: elapsed,
      token_in: usageParsed.token_in,
      token_out: usageParsed.token_out,
      cost: usageParsed.cost
    },
    debug: {
      model_path: ['provider:dify', `workflow:${context.workflowId || 'api-key-bound'}`],
      kb_hits: kbHits,
      kb_hits_source: hasUpstreamKbHits ? 'dify' : 'planned_fallback',
      route: {
        sub_type: context.subType || 'unknown',
        workflow_id: context.workflowId || null,
        sub_type_profile: context.subTypeProfile || null,
        prompt_plan: context.promptPlan || null,
        knowledge: context.knowledge || null,
        kb_registry: context.kb_registry || null,
        kb_mapping: context.kb_mapping || null,
        retry_index: Number(context.retryIndex || 0)
      }
    },
    raw: {
      workflow_run_id: data.workflow_run_id || null,
      task_id: data.task_id || null,
      usage: data.usage || null
    }
  }
}

function mapUpstreamError(status, payload) {
  const message = payload?.message || payload?.error || `HTTP_${status}`
  if (status === 404) {
    return makeProviderError('WORKFLOW_NOT_FOUND', `dify workflow not found: ${message}`, { upstream_status: status })
  }
  if (status === 408 || status === 504) {
    return makeProviderError('UPSTREAM_TIMEOUT', `dify timeout: ${message}`, { upstream_status: status })
  }
  return makeProviderError('UPSTREAM_ERROR', `dify upstream error: ${message}`, { upstream_status: status })
}

async function callDifyWorkflow({ payload, scenario, policy, traceId, tenantId, streamManager, context, timeoutMsOverride }) {
  const cfg = getDifyConfig()
  if (!cfg.enabled) {
    throw makeProviderError('UPSTREAM_ERROR', 'dify is disabled')
  }

  if (!cfg.baseUrl) {
    throw makeProviderError('UPSTREAM_ERROR', 'dify is not configured')
  }

  const apiKey = resolveApiKey(cfg, context.workflowId)
  if (!apiKey) {
    throw makeProviderError('WORKFLOW_NOT_FOUND', `api key for workflow ${context.workflowId || 'default'} is not configured`)
  }

  const timeoutMs = Number(timeoutMsOverride || cfg.timeoutMs)
  const controller = new AbortController()
  const timeout = setTimeout(() => controller.abort(), timeoutMs)

  const startedAt = Date.now()
  streamManager.publish(traceId, 'progress', {
    trace_id: traceId,
    stage: 'dify_requesting',
    progress: 35,
    message: 'calling dify workflow'
  })

  try {
    const url = `${cfg.baseUrl}/v1/workflows/run`
    const body = buildDifyInput(payload, scenario, policy, traceId, tenantId, context)

    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${apiKey}`
      },
      body: JSON.stringify(body),
      signal: controller.signal
    })

    const rawText = await response.text()
    let json
    try {
      json = rawText ? JSON.parse(rawText) : {}
    } catch (_error) {
      throw makeProviderError('UPSTREAM_ERROR', 'dify returned non-json response', { body_preview: rawText.slice(0, 300) })
    }

    if (!response.ok) {
      throw mapUpstreamError(response.status, json)
    }

    streamManager.publish(traceId, 'progress', {
      trace_id: traceId,
      stage: 'dify_responded',
      progress: 85,
      message: 'dify response received'
    })

    return normalizeDifyResult(traceId, scenario.scenario_id, json, startedAt, context)
  } catch (error) {
    if (error && error.name === 'AbortError') {
      throw makeProviderError('UPSTREAM_TIMEOUT', 'dify request timeout', { timeout_ms: timeoutMs })
    }
    throw error
  } finally {
    clearTimeout(timeout)
  }
}

module.exports = {
  getDifyConfig,
  callDifyWorkflow
}
